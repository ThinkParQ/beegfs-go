package index

import (
	"fmt"
	"os"
	"os/exec"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/thinkparq/beegfs-go/ctl/pkg/config"
)

type updateIndexConfig struct {
	maxMemory string
	fsPath    string
	indexPath string
	summary   bool
	xattrs    bool
	version   bool
	maxLevel  uint
	scanDirs  bool
	port      uint
	mntPath   string
}

func newGenericUpdateCmd() *cobra.Command {
	cfg := updateIndexConfig{}

	var cmd = &cobra.Command{
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := checkBeeGFSConfig(); err != nil {
				return err
			}
			return runPythonUpdateIndex(&cfg)
		},
	}

	cmd.Flags().StringVar(&cfg.fsPath, "fs-path", "", "File system path for which index will be updated [default: IndexEnv.conf]")
	cmd.Flags().StringVar(&cfg.indexPath, "index-path", "", "Index directory path [default: IndexEnv.conf]")
	cmd.Flags().StringVar(&cfg.maxMemory, "max-memory", "", "Max memory usage (e.g. 8GB, 1G)")
	cmd.Flags().BoolVar(&cfg.summary, "summary", false, "Update tree summary table along with other tables")
	cmd.Flags().BoolVar(&cfg.xattrs, "xattrs", false, "Pull xattrs from source")
	cmd.Flags().BoolVar(&cfg.version, "version", false, "BeeGFS Hive Index Version")
	cmd.Flags().UintVar(&cfg.maxLevel, "max-level", 0, "Max level to go down")
	cmd.Flags().BoolVar(&cfg.scanDirs, "scan-dirs", false, "Print the number of scanned directories")
	cmd.Flags().UintVar(&cfg.port, "port", 0, "Port number to connect with client")

	return cmd
}

func newUpdateCmd() *cobra.Command {
	s := newGenericUpdateCmd()
	s.Use = "update"
	s.Short = "Updates the index"
	s.Long = `Updates the index directory with ongoing operations

BeeGFS Hive Index uses modification events generated by BeeGFS metadata nodes
to update the index directory.The modification logs from BeeGFS have the file
path on which the operation is performed.The bee-update service takes advantage
of these events and modifies the Index directory for the specific file(s) or
directories only.This mechanism avoids scanning the filesystem entirely to
update the Index directory, ensuring that the index directory remains up-to-date
with filesystem modifications.

Event listener should be started on all the metadata nodes so that all filesystem
operations can be captured and replayed on the index directory by bee update.
`
	return s
}

func validateUpdateInputs(cfg *updateIndexConfig) error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	beegfsClient, err := config.BeeGFSClient(cwd)
	if err != nil {
		return err
	}
	cfg.mntPath = beegfsClient.GetMountPath()
	return nil
}

func runPythonUpdateIndex(cfg *updateIndexConfig) error {
	if err := validateUpdateInputs(cfg); err != nil {
		return err
	}

	args := []string{
		"index",
	}

	if cfg.fsPath != "" {
		args = append(args, "-F", cfg.fsPath)
	}
	if cfg.indexPath != "" {
		args = append(args, "-I", cfg.indexPath)
	}
	if cfg.maxMemory != "" {
		args = append(args, "-X", cfg.maxMemory)
	}
	args = append(args, "-n", fmt.Sprint(viper.GetInt(config.NumWorkersKey)))
	if cfg.summary {
		args = append(args, "-S")
	}
	if cfg.xattrs {
		args = append(args, "-x")
	}
	if cfg.version {
		args = append(args, "-v")
	}
	if cfg.maxLevel > 0 {
		args = append(args, "-z", fmt.Sprint(cfg.maxLevel))
	}
	if cfg.scanDirs {
		args = append(args, "-C")
	}
	if cfg.port > 0 {
		args = append(args, "-p", fmt.Sprint(cfg.port))
	}
	if cfg.mntPath != "" {
		args = append(args, "-M", cfg.mntPath)
	}
	if viper.GetBool(config.DebugKey) {
		args = append(args, "-V", "1")
	}
	args = append(args, "-U")

	cmd := exec.Command(beeBinary, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err := cmd.Start()
	if err != nil {
		return fmt.Errorf("error starting command: %v", err)
	}
	err = cmd.Wait()
	if err != nil {
		return fmt.Errorf("error executing beeBinary: %v", err)
	}
	return nil
}
