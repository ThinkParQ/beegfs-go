package index

import (
	"fmt"
	"os"
	"os/exec"

	"github.com/spf13/cobra"
	"github.com/thinkparq/beegfs-go/ctl/internal/bflag"
)

const updateCmd = "index"

func newGenericUpdateCmd() *cobra.Command {
	var bflagSet *bflag.FlagSet

	var cmd = &cobra.Command{
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := checkBeeGFSConfig(); err != nil {
				return err
			}
			return runPythonUpdateIndex(bflagSet)
		},
	}

	bflagSet = bflag.NewFlagSet(commonIndexFlags, cmd)
	cmd.Flags().MarkHidden("update")
	return cmd
}

func newUpdateCmd() *cobra.Command {
	s := newGenericUpdateCmd()
	s.Use = "update"
	s.Short = "Updates the index directory with recent changes."

	s.Long = `Update the index directory with ongoing filesystem operations.

The BeeGFS Hive Index uses modification events from BeeGFS metadata nodes to keep
the index directory up-to-date. Modification logs generated by BeeGFS contain the file paths
on which operations are performed. The update service leverages these events to update
only the relevant files or directories in the index directory. This method avoids
the need for a full filesystem scan, efficiently keeping the index synchronized with
file system changes.

To capture all filesystem operations, an event listener must be started on each metadata node.
This ensures that every modification is recorded and can be applied to the index directory
through beegfs index update.
`
	return s
}

func runPythonUpdateIndex(bflagSet *bflag.FlagSet) error {
	wrappedArgs := bflagSet.WrappedArgs()
	allArgs := make([]string, 0, len(wrappedArgs)+2)
	allArgs = append(allArgs, updateCmd)
	allArgs = append(allArgs, wrappedArgs...)
	allArgs = append(allArgs, "-U")
	cmd := exec.Command(beeBinary, allArgs...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err := cmd.Start()
	if err != nil {
		return fmt.Errorf("unable to start index command: %w", err)
	}
	err = cmd.Wait()
	if err != nil {
		return fmt.Errorf("error executing index command: %w", err)
	}
	return nil
}
