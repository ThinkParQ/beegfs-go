name: "Build, Test, and Publish"

on:
  workflow_dispatch:
  push:
    branches:
      - "main"
    tags:
      - "[0-9]+.[0-9]+.[0-9]+"
  pull_request:
    branches:
      - "main"

env:
  # Container image registry to publish images to:
  REGISTRY: ghcr.io
  # Where to push an image that will be retained (for master builds or releases) without a specific tag:
  IMAGE_NAME: ghcr.io/thinkparq/bee-watch
  # Where to push an image for testing (including the operator) without a specific tag:
  TEST_IMAGE_NAME: ghcr.io/thinkparq/test-bee-watch
  GOPRIVATE: github.com/thinkparq/*

jobs:
  build-test-package:
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    permissions:
      packages: write
      contents: read
    steps:
      - uses: actions/checkout@v3
        with:
          # By default the checkout will do a shallow clone. With how we
          # generate versions we specify "0" to get the full commit history
          # because the last version tag may be any N of commits back.    
          fetch-depth: "0"   
      # The build tests include a "go mod tidy" step, which requires access to
      # all Go modules used during the project's build process. This presents a
      # challenge when our project depends on private Go modules from other
      # repositories within our organization. Currently the GITHUB_TOKEN
      # generated for GitHub Actions workflows has permissions limited to the
      # current repository, meaning it cannot access other private
      # repositoriesâ€”even within the same organization.
      #
      # To address this limitation, iamjoemccormick has generated a fine-grained
      # Personal Access Token (PAT) with read access to the necessary
      # repositories. This PAT is securely stored as a secret on this repository
      # and used to provide GitHub Actions with the required access. Note: Care
      # has been taken to limit the PAT's permissions to the bare minimum needed
      # for this workflow.
      #
      # We then setup HTTP authentication for Git:
      # https://go.dev/doc/faq#git_https which is used by "go get" to clone
      # repositories.
      - name: Setup .netrc for private Go modules
        run: |
          echo "machine github.com login x-access-token password ${{ secrets.PROJECT_FLEX_CI_TOKEN }}" > $HOME/.netrc

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.20.6
      # Dependencies are cached by default: https://github.com/actions/setup-go#v4
      # This can be explicitly disabled if it ever causes problems.      

      - name: Install tools required for the build and packaging process
        run: |
          make install-tools   

      - name: Run all tests
        run: |
          make test

      - name: Create Debian package
        run: |
          make package-deb
          deb_pkg_name=$(ls packages/deb)
          echo "DEB_PKG_NAME=$deb_pkg_name" >> $GITHUB_ENV

      - name: Save Debian package as an artifact (${{ env.DEB_PKG_NAME }})
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.DEB_PKG_NAME }}
          path: packages/deb/${{ env.DEB_PKG_NAME }}

      - name: Create RPM package]
        run: |
          make package-rpm
          rpm_pkg_name=$(ls packages/rpm/x86_64)
          echo "RPM_PKG_NAME=$rpm_pkg_name" >> $GITHUB_ENV

      - name: Save RPM package as an artifact (${{ env.RPM_PKG_NAME }})
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.RPM_PKG_NAME }}
          path: packages/rpm/${{ env.RPM_PKG_NAME }}

      - name: Create Container Image
        run: |
          make package-docker IMAGE_NAME=${{ env.TEST_IMAGE_NAME }}

      - name: Log into the GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Push the image for reuse in subsequent steps, jobs, workflows or for testing.
      - name: Push the the container image as a test package
        run: |
          image_tag=$(docker images | grep ${{ env.TEST_IMAGE_NAME }} | awk '{print $2}')
          docker push ${{ env.TEST_IMAGE_NAME }}:$image_tag
          echo "IMAGE_TAG=$image_tag" >> $GITHUB_ENV

  publish:
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    # We only run e2e tests for PRs and we only publish-images when we aren't on a PR. 
    # This means publish-images has to be wired to build-and-unit-test otherwise it will always get skipped.
    needs: [build-test-package]
    if: github.event_name != 'pull_request'
    permissions:
      packages: write
      contents: read
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # TODO: Enable - https://github.com/ThinkParQ/bee-watch/issues/19
      # - name: Install Cosign
      #   uses: sigstore/cosign-installer@v3.1.1
      #   with:
      #     cosign-release: "v2.1.1"

      - name: Pull tested container image from ghcr.io
        run: |
          docker pull ${{ env.TEST_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Log in to the GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # This uses the semantic versioning option for https://github.com/docker/metadata-action#semver
      - name: Extract metadata for container image
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      # TODO: Consider adding labels available as steps.meta.output.labels.
      - name: Tag and push the container image to GitHub Container Registry
        run: |
          tags=$(echo "${{ steps.meta.outputs.tags }}" | tr '\n' ' ')
          for tag in $tags; do
            docker tag ${{ env.TEST_IMAGE_NAME }}:${{ env.IMAGE_TAG }} $tag
            docker push $tag
          done

      # TODO: Enable - https://github.com/ThinkParQ/bee-watch/issues/19
      # # Adapted from:
      # # https://github.blog/2021-12-06-safeguard-container-signing-capability-actions/
      # # https://github.com/sigstore/cosign-installer#usage
      # - name: Sign container image with Cosign
      #   run: |
      #     tags=$(echo "${{ steps.meta.outputs.tags }}" | tr '\n' ' ')
      #     for tag in $tags; do
      #       DIGEST=$(docker image inspect $tag --format '{{index .RepoDigests 0}}')
      #       cosign sign --yes --key env://COSIGN_PRIVATE_KEY \
      #       -a "repo=${{ github.repository }}" \
      #       -a "run=${{ github.run_id }}" \
      #       -a "ref=${{ github.sha }}" \
      #       $DIGEST
      #     done
      #   env:
      #     COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
      #     COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}

  # We'll keep around a few old test packages to (a) avoid deleting image for workflows running in parallel,
  # and (b) it may be useful to pull a package to troubleshoot workflow failures.
  cleanup:
    runs-on: ubuntu-22.04
    timeout-minutes: 3
    needs: build-test-package
    if: always()
    steps:
      - name: Extract CSI driver test package name
        run: |
          test_image_name="${{ env.TEST_IMAGE_NAME }}"
          test_image_pkg=${test_image_name##*/}
          echo "TEST_IMAGE_PKG=$test_image_pkg" >> $GITHUB_ENV

      - name: Cleanup old ${{ env.TEST_IMAGE_PKG }} packages
        uses: actions/delete-package-versions@v4
        with:
          package-name: "${{ env.TEST_IMAGE_PKG }}"
          package-type: "container"
          min-versions-to-keep: 5