package config

import (
	"fmt"
	"reflect"

	"github.com/mitchellh/mapstructure"
	"github.com/thinkparq/bee-remote/internal/job"
	"github.com/thinkparq/bee-remote/internal/server"
	"github.com/thinkparq/gobee/configmgr"
	"github.com/thinkparq/gobee/logger"
	beegfs "github.com/thinkparq/protobuf/beegfs/go"
)

// We use ConfigManager to handle configuration updates.
// Verify all interfaces that depend on AppConfig are satisfied.
var _ configmgr.Configurable = &AppConfig{}

type AppConfig struct {
	RemoteStorageTargets []*beegfs.RemoteStorageTarget `mapstructure:"remote_storage_target"`
	Server               server.Config                 `mapstructure:"server"`
	Log                  logger.Config                 `mapstructure:"log"`
	Job                  job.Config                    `mapstructure:"job"`
	Developer            struct {
		PerfProfilingPort int  `mapstructure:"perfProfilingPort"`
		DumpConfig        bool `mapstructure:"dumpConfig"`
	}
}

// NewEmptyInstance() returns an empty AppConfig for ConfigManager to use with
// when unmarshalling the configuration.
func (c *AppConfig) NewEmptyInstance() configmgr.Configurable {
	return new(AppConfig)
}

func (c *AppConfig) UpdateAllowed(newConfig configmgr.Configurable) error {
	// TODO: Implement
	return nil
}

func (c *AppConfig) ValidateConfig() error {
	// TODO: Implement
	return nil
}

// SetRSTTypeHook provides a custom decoding hook for the mapstructure package.
// It specifically addresses the challenge of decoding a "oneof" field generated
// by protoc into an appropriate struct when unmarshalling configurations with
// Viper.
//
// Background: Our ConfigMgr package uses Viper which in turn uses the
// mapstructure package to decode map[string]interface{} values into
// specific struct types. However, a challenge arises when decoding "oneof"
// fields generated by protoc. These fields manifest as unique interface fields
// in the Go struct, and every permissible type for that field has to implement
// this interface.
//
// Problem: Without custom handling, attempts to decode a RemoteStorageTarget (RST)
// type will lead to errors like:
//
// `'remote_storage_target[0].Type' expected type
// 'beegfs.isRemoteStorageTarget_Type', got 'map[string]interface {}'`
//
// Solution: SetRSTTypeHook allows end users to detail configuration for specific
// RST types in TOML using dotted keys. The prefix before the first dot
// represents the RST type. Viper then consolidates all key/value pairs for that
// type into a map. This function leverages that map to correctly create the
// corresponding structs based on the RST type.
//
// The methodology adopted here draws inspiration from:
// https://sagikazarmark.hu/blog/decoding-custom-formats-with-viper/.
func SetRSTTypeHook() mapstructure.DecodeHookFuncType {

	// supportedRSTTypes allows us work with multiple RST types without writing
	// repetitive code. The map contains the all lowercase string identifier of
	// the prefix key of the TOML table used to indicate the configuration
	// options for a particular RST type. For each RST type a function must be
	// returned that can be used to construct the actual structs that will be
	// set to the Type field. The first return value is a new struct that
	// satisfies the isRemoteStorageTarget_Type interface. The second return
	// value is the address of the struct that is a named field of the first
	// return struct and contains the actual message fields for that RST type.
	// Note returning the address is important otherwise you will get an
	// initialized but empty struct of the correct type.
	//
	// IMPORTANT: When a new RST type is added to `beegfs.proto` it must also be
	// added to supportedRSTTypes before configuration for the new RST type will
	// be unmarshalled from the AppConfig.
	var supportedRSTTypes = map[string]func() (any, any){
		"s3":    func() (any, any) { t := new(beegfs.RemoteStorageTarget_S3_); return t, &t.S3 },
		"azure": func() (any, any) { t := new(beegfs.RemoteStorageTarget_Azure_); return t, &t.Azure },
	}

	return func(
		f reflect.Type, // data type
		t reflect.Type, // target data type
		data interface{}, // raw data
	) (interface{}, error) {

		if t.String() == "beegfs.RemoteStorageTarget" {
			switch f.Kind() {
			case reflect.Map:
				if tmpData, ok := data.(map[string]interface{}); ok {
					for key, config := range tmpData {
						if constructor, exists := supportedRSTTypes[key]; exists {
							newType, newTypeField := constructor()
							if _, alreadyExists := tmpData["Type"]; alreadyExists {
								return nil, fmt.Errorf("configuration for different types of Remote Storage Targets was found on the same target")
							}
							if err := mapstructure.Decode(config, &newTypeField); err != nil {
								return nil, err
							}
							tmpData["Type"] = newType
							delete(tmpData, key)
						}
					}

					// It may be easier to understand the above by looking at how
					// this would look if we decoded each type directly. Here we
					// construct a newType and use its newType.S3 field with
					// mapstructure.Decode() to decode the configuration from the
					// map[string]interface. If decoding is successful newType is a
					// valid RST and we can set Type equal to its address.
					//
					// if config, exists := tmpData["s3"]; exists {
					//  var newType beegfs.RemoteStorageTarget_S3_
					//  if err := mapstructure.Decode(config, &newType.S3); err != nil {
					//      return nil, err
					//  }
					//  tmpData["Type"] = &newType
					//  delete(tmpData, "s3")
					// }
				}
			}
		}

		return data, nil
	}
}
