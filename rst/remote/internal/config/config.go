package config

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/mitchellh/mapstructure"
	"github.com/thinkparq/bee-remote/remote/internal/job"
	"github.com/thinkparq/bee-remote/remote/internal/server"
	"github.com/thinkparq/bee-remote/remote/internal/worker"
	"github.com/thinkparq/bee-remote/remote/internal/workermgr"
	"github.com/thinkparq/beegfs-go/common/configmgr"
	"github.com/thinkparq/beegfs-go/common/logger"
	"github.com/thinkparq/beegfs-go/common/rst"
	"github.com/thinkparq/beegfs-go/common/types"
	"github.com/thinkparq/protobuf/go/flex"
)

// We use ConfigManager to handle configuration updates.
// Verify all interfaces that depend on AppConfig are satisfied.
var _ configmgr.Configurable = &AppConfig{}

type AppConfig struct {
	MountPoint           string                      `mapstructure:"mount-point"`
	Management           MgmtdConfig                 `mapstructure:"management"`
	Server               server.Config               `mapstructure:"server"`
	Log                  logger.Config               `mapstructure:"log"`
	Job                  job.Config                  `mapstructure:"job"`
	WorkerMgr            workermgr.Config            `mapstructure:"worker-mgr"`
	Workers              []worker.Config             `mapstructure:"worker"`
	RemoteStorageTargets []*flex.RemoteStorageTarget `mapstructure:"remote-storage-target"`
	Developer            struct {
		PerfProfilingPort int  `mapstructure:"perf-profiling-port"`
		DumpConfig        bool `mapstructure:"dump-config"`
	}
}

type MgmtdConfig struct {
	Address                string `mapstructure:"address"`
	TLSCertFile            string `mapstructure:"tls-cert-file"`
	TLSDisableVerification bool   `mapstructure:"tls-disable-verification"`
	TLSDisable             bool   `mapstructure:"tls-disable"`
	AuthFile               string `mapstructure:"auth-file"`
	AuthDisable            bool   `mapstructure:"auth-disable"`
}

// NewEmptyInstance() returns an empty AppConfig for ConfigManager to use with
// when unmarshalling the configuration.
func (c *AppConfig) NewEmptyInstance() configmgr.Configurable {
	return new(AppConfig)
}

func (c *AppConfig) UpdateAllowed(newConfig configmgr.Configurable) error {
	// TODO: https://github.com/ThinkParQ/bee-remote/issues/29.
	// At least allow RST configuration to be dynamically updated.
	return nil
}

func (c *AppConfig) ValidateConfig() error {

	var multiErr types.MultiError
	if c.Job.PathDBPath == "" {
		multiErr.Errors = append(multiErr.Errors, fmt.Errorf("job.path-db-path must be set to a valid path (provided path: '%s')", c.Job.PathDBPath))
	}

	if c.Job.MinJobEntriesPerRST < 1 {
		return fmt.Errorf("the job.min-job-entries-per-rst must be one or greater (provided value: %d)", c.Job.MinJobEntriesPerRST)
	}

	if c.Job.MaxJobEntriesPerRST < c.Job.MinJobEntriesPerRST {
		return fmt.Errorf("the job.max-job-entries-per-rst (%d) cannot be less than the job.min-job-entries-per-rst (%d)", c.Job.MaxJobEntriesPerRST, c.Job.MinJobEntriesPerRST)
	}

	// TODO: https://github.com/ThinkParQ/bee-remote/issues/29
	// At least add checks for RST configuration before allowing it to be updated dynamically.

	if len(multiErr.Errors) > 0 {
		return &multiErr
	}
	return nil
}

// SetRSTTypeHook provides a custom decoding hook for the mapstructure package.
// It specifically addresses the challenge of decoding a "oneof" field generated
// by protoc into an appropriate struct when unmarshalling configurations with
// Viper.
//
// Background: Our ConfigMgr package uses Viper which in turn uses the
// mapstructure package to decode map[string]interface{} values into
// specific struct types. However, a challenge arises when decoding "oneof"
// fields generated by protoc. These fields manifest as unique interface fields
// in the Go struct, and every permissible type for that field has to implement
// this interface.
//
// Problem: Without custom handling, attempts to decode a RemoteStorageTarget (RST)
// type will lead to errors like:
//
// `'remote_storage_target[0].Type' expected type
// 'beegfs.isRemoteStorageTarget_Type', got 'map[string]interface {}'`
//
// Solution: SetRSTTypeHook allows end users to detail configuration for specific
// RST types in TOML using dotted keys. The prefix before the first dot
// represents the RST type. Viper then consolidates all key/value pairs for that
// type into a map. This function leverages that map to correctly create the
// corresponding structs based on the RST type.
//
// The methodology adopted here draws inspiration from:
// https://sagikazarmark.hu/blog/decoding-custom-formats-with-viper/.
//
// IMPORTANT: When a new RST type is added to `beegfs.proto` it must also be
// added to rst.SupportedRSTTypes before configuration for the new RST type will
// be unmarshalled from the AppConfig.
func SetRSTTypeHook() mapstructure.DecodeHookFuncType {

	return func(
		f reflect.Type, // data type
		t reflect.Type, // target data type
		data interface{}, // raw data
	) (interface{}, error) {

		// If the name of the flex package ever changes this will need to be updated.
		if t.String() == "flex.RemoteStorageTarget" {
			switch f.Kind() {
			case reflect.Map:
				if tmpData, ok := data.(map[string]interface{}); ok {
					for key, config := range tmpData {
						if constructor, exists := rst.SupportedRSTTypes[key]; exists {
							newType, newTypeField := constructor()
							if _, alreadyExists := tmpData["Type"]; alreadyExists {
								return nil, fmt.Errorf("cannot mix configuration for different types of remote storage targets on the same target")
							}
							// Use a custom mapstructure decoder to allow the use of kebab-case for
							// mapKeys. This is required because there is no way to add mapstructure
							// tags to protobuf generated code. This implementation does mean that
							// both "endpoint-url" and "endpointUrl" could be specified and only one
							// would actually take effect (it would probably be somewhat random
							// which one). Note this only applies to keys for different RST types,
							// not top level RST parameters such as policies.
							dec, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
								Metadata:    nil,
								Result:      &newTypeField,
								ErrorUnused: true, // Ensure any unknown configuration will return an error.
								MatchName: func(mapKey, fieldName string) bool {
									return strings.ReplaceAll(strings.ToLower(mapKey), "-", "") == strings.ToLower(fieldName)
								},
							})
							if err != nil {
								return nil, fmt.Errorf("unexpected error setting up mapstructure decoder (probably this is a bug): %w", err)
							}
							err = dec.Decode(config)
							if err != nil {
								return nil, fmt.Errorf("%s: %w", key, err)
							}
							tmpData["Type"] = newType
							delete(tmpData, key)
						}
					}

					// It may be easier to understand the above by looking at how
					// this would look if we decoded each type directly. Here we
					// construct a newType and use its newType.S3 field with
					// mapstructure.Decode() to decode the configuration from the
					// map[string]interface. If decoding is successful newType is a
					// valid RST and we can set Type equal to its address.
					//
					// if config, exists := tmpData["s3"]; exists {
					//  var newType beegfs.RemoteStorageTarget_S3_
					//  if err := mapstructure.Decode(config, &newType.S3); err != nil {
					//      return nil, err
					//  }
					//  tmpData["Type"] = &newType
					//  delete(tmpData, "s3")
					// }
				}
			}
		}

		return data, nil
	}
}
